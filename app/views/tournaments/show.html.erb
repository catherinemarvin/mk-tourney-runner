<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.2/svg.min.js" integrity="sha512-I+rKw3hArzZIHzrkdELbKqrXfkSvw/h0lW/GgB8FThaBVz2e5ZUlSW8kY8v3q6wq37eybIwyufkEZxe4qSlGcg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<h1><%= @tournament.title %></h1>

<h1>Players</h1>
<ul>
<% @tournament.players.each do |player| %>
    <li>
        <%= player.name %>
    </li>

<% end %>
</ul>

<h1>Rounds</h1>
<ul>
<% @tournament.rounds.each do |round| %>
    <li>Round: <%= round.position %></li>
    <ul>
        <% round.players.each do |player| %>
            <li><%= player.name %></li>
        <% end %>
        <ul> Next Rounds:
            <% round.next_rounds.each do |round| %>
                <li><%= round.position %></li>
            <% end %>
        </ul>
    </ul>

<% end %>
</ul>

<%= link_to "Edit", edit_tournament_url(@tournament) %>

<script>
var rounds = <%== @rounds_json %>;

// key: int value: SVG rect
var roundPositionToSVG = {};

// key: int value: int describing the level (0, 1, or 2)
var roundPositionToLevel = {};
initializeRoundPositionToLevel();

// height of round
let roundHeight = 100;
// vertical padding between rounds
let heightPadding = 20;

// width of round
let roundWidth = 100;
// horizontal padding between rounds
let widthPadding = 40;

// how much to lower each successive level
let levelLowerAmount = 50;

// height of marker
let markerHeight = 4;
// width of marker
let markerWidth = 4;

var draw = SVG().addTo('body').size(3 * (roundWidth + widthPadding), 3 * (roundHeight + heightPadding + levelLowerAmount));

var marker = draw.marker(markerWidth, markerHeight, function (add) {
    add.polygon([
        [0, 0],
        [markerWidth, markerHeight / 2],
        [0, markerHeight]
    ])
}).ref(0, markerHeight / 2);

var startingContainer = draw.nested().move(0,0);
var intermediateContainer = draw.nested().move(roundWidth + widthPadding, levelLowerAmount);
var finalContainer = draw.nested().move(2 * (roundWidth + widthPadding), levelLowerAmount * 2);

drawLevel(startingContainer, rounds.starting_rounds);
drawLevel(intermediateContainer, rounds.intermediate_rounds);
drawLevel(finalContainer, [rounds.final_round]);

for (var r of rounds.starting_rounds) {
    drawNextRoundArrows(r);
}
for (var r of rounds.intermediate_rounds) {
    drawNextRoundArrows(r);
}

function initializeRoundPositionToLevel() {
    for (var round of rounds.starting_rounds) {
        roundPositionToLevel[round.index] = 0;
    }
    for (var round of rounds.intermediate_rounds) {
        roundPositionToLevel[round.index] = 1;
    }
    roundPositionToLevel[rounds.final_round.index] = 2;
}

// container: SVG container, rounds: array of objects
function drawLevel(container, rounds) {
    var dy = 0;
    for (var r of rounds) {
        var rect = container.rect(roundHeight, roundWidth).move(0, dy).attr({ fill: '#f06' });
        var playersContainer = container.nested().move(0, dy);
        drawPlayers(playersContainer, r.players);

        roundPositionToSVG[r.index] = rect;
        dy += roundHeight + heightPadding
    }
}

// container: SVG container
// Players: array of names
function drawPlayers(container, players) {
    var dy = 0;
    for (var p of players) {
        container.text(p.name).move(0,dy).font({ fill: '#000' });
        dy += 20;
    }
}

// round: object    
function drawNextRoundArrows(round) {
    var sourceLevel = roundPositionToLevel[round.index];
    var sourceRect = roundPositionToSVG[round.index];
    var sourceBBox = sourceRect.rbox(draw);

    for (var destinationIndex of round.next_round_positions) {
        var destinationRect = roundPositionToSVG[destinationIndex];
        var destinationLevel = roundPositionToLevel[destinationIndex];
        var destBBox = destinationRect.rbox(draw);

        // If directly adjacent, draw an arrow from middle
        if (destinationLevel - sourceLevel == 1) {
            draw.line(
                    sourceBBox.x + sourceRect.width(), 
                    sourceBBox.y + (sourceRect.height() / 2),
                    destBBox.x,
                    sourceBBox.y + (sourceRect.height() / 2))
                .stroke({ color: 'black', width: 4})
                .marker('end', marker);
        } else if (destinationLevel - sourceLevel > 1) {
            // else, draw an arrow from the top
            draw.polyline(
                [
                    [sourceBBox.x + sourceBBox.width, sourceBBox.y + 4],
                    [destBBox.x + (destBBox.width / 2), sourceBBox.y + 4],
                    [destBBox.x + (destBBox.width / 2), destBBox.y]
                ])
                .fill('none')
                .stroke({ color: 'black', width: 4 })
                .marker('end', marker);
        } else {
            console.log("something went wrong");
        }
    }

}

</script>
